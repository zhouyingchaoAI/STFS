# 日客流预测算法详细分析

## 一、算法架构概述

日客流预测系统采用**混合预测模型**，结合了**KNN回归算法**和**去年同期+偏移预测算法**，通过加权融合得到最终预测结果。

### 1.1 整体流程

```
数据读取 → 数据预处理 → 模型训练/加载 → 双算法预测 → 加权融合 → 结果输出
```

## 二、核心组件

### 2.1 主要模块

1. **`predict_daily.py`** - 主流程协调模块
2. **`enknn_model.py`** - KNN预测器实现
3. **`db_utils.py`** - 数据读取与存储
4. **`config_utils.py`** - 配置管理

### 2.2 数据流

```
数据库 → read_line_daily_flow_history() 
      → DataFrame预处理 
      → 因子提取 
      → KNNFlowPredictor.predict() 
      → 结果写入数据库
```

## 三、预测算法详解

### 3.1 混合预测架构

系统使用两种独立算法并行预测，然后加权融合：

#### 算法1：KNN回归预测

**原理：**
- 基于K近邻回归（K-Nearest Neighbors Regression）
- 在特征空间中寻找与预测日期最相似的K个历史日期
- 使用距离加权平均得到预测值

**特征因子（7个）：**
```python
DEFAULT_KNN_FACTORS = [
    'F_WEEK',           # 周数（1-53）
    'F_HOLIDAYTYPE',    # 节假日类型
    'F_HOLIDAYDAYS',    # 节假日天数
    'F_HOLIDAYWHICHDAY', # 节假日第几天
    'F_DAYOFWEEK',      # 星期几（1-7）
    'WEATHER_TYPE',     # 天气类型
    'F_YEAR'            # 年份
]
```

**训练过程：**
1. 数据标准化（StandardScaler）
2. 目标变量对数变换（log1p），处理非负偏态分布
3. K值网格搜索（默认 [3, 5, 7, 9]）
4. 选择MSE最小的K值
5. 使用距离加权（weights='distance'）

**预测过程：**
1. 加载训练好的模型和标准化器
2. 构建预测日期的特征向量
3. 标准化特征
4. KNN预测（对数空间）
5. 逆变换（expm1）得到原始尺度预测值

#### 算法2：去年同期+偏移预测

**原理：**
- 使用去年同期同日的实际客流作为基础值
- 计算近期整体趋势偏移量
- 应用偏移量调整预测值
- 节假日特殊处理：偏移量上浮20%

**详细步骤：**

1. **获取去年同期数据**
   ```python
   last_year_date = predict_date.replace(year=predict_date.year - 1)
   base_flow = 历史数据[last_year_date]['F_KLCOUNT']
   ```

2. **计算偏移量**
   - 偏移区间：预测起始日期前days天
   - 今年偏移区间客流总和 vs 去年同期偏移区间客流总和
   - 平均每日偏移 = (今年总和 - 去年总和) / days

3. **节假日调整**
   ```python
   if is_holiday:
       offset = offset + abs(offset) * 0.2  # 上浮20%
   ```

4. **预测值计算**
   ```python
   prediction = max(base_flow + offset, 0.0)
   ```

**边界情况处理：**
- 闰年2月29日 → 使用2月28日
- 去年同期数据缺失 → 使用偏移区间平均值
- 数据完全缺失 → 返回0

### 3.2 加权融合策略

**默认权重配置：**
```python
global_algorithm_weights = {
    "knn": 0.8,              # KNN算法权重
    "last_year_offset": 0.2  # 去年同期+偏移算法权重
}
```

**融合公式：**
```python
final_prediction = knn_weight * knn_prediction + offset_weight * offset_prediction
final_prediction = max(final_prediction, 0.0)  # 确保非负
```

**线路级别权重：**
- 支持为每条线路配置独立权重
- 优先使用线路权重，否则使用全局权重
- 权重自动归一化

## 四、数据预处理

### 4.1 数据读取

**主要数据源：**
- `LineDailyFlowHistory` - 线路日客流历史数据
- `CalendarHistory` - 日历特征数据
- `LSTM_COMMON_HOLIDAYFEATURE` - 节假日特征数据
- `WeatherHistory` - 天气历史数据

**数据字段：**
```python
factor_cols = [
    'F_DATE',              # 日期
    'F_WEEK',              # 周数
    'F_HOLIDAYTYPE',       # 节假日类型
    'F_HOLIDAYDAYS',       # 节假日天数
    'F_HOLIDAYWHICHDAY',   # 节假日第几天
    'F_DAYOFWEEK',         # 星期几
    'F_LINENO',            # 线路编号
    'F_LINENAME',          # 线路名称
    'F_KLCOUNT',           # 客流数量（目标变量）
    'F_WEATHER',           # 天气
    'WEATHER_TYPE'         # 天气类型
]
```

### 4.2 数据清洗

```python
# 1. 删除缺失关键字段的记录
df = df.dropna(subset=['F_DATE', 'F_KLCOUNT', 'F_LINENO'])

# 2. 数据类型转换
df['F_DATE'] = df['F_DATE'].astype(str).str.strip()
df['F_KLCOUNT'] = pd.to_numeric(df['F_KLCOUNT'], errors='coerce').fillna(0)
df['F_LINENO'] = df['F_LINENO'].astype(str).str.zfill(2)

# 3. 因子标准化
df['WEATHER_TYPE'] = WeatherType.get_weather_by_name(str(x)).value
```

### 4.3 特征工程

**KNN特征准备：**
```python
# 1. 确保因子为数值型
df = _ensure_numeric_data(df, factors)

# 2. 提取特征矩阵X和目标变量y
X = df[factors].values.astype(np.float64)
y = df['F_KLCOUNT'].values.astype(np.float64)

# 3. 目标变量对数变换（处理偏态分布）
y_transformed = np.log1p(y)

# 4. 特征标准化
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
```

## 五、模型训练

### 5.1 训练流程

```python
def train(line_data, line_no, model_version):
    # 1. 数据准备
    X, y = prepare_data(line_data)  # y已对数变换
    
    # 2. K值网格搜索
    for k in [3, 5, 7, 9]:
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        
        model = KNeighborsRegressor(
            n_neighbors=k,
            weights='distance',      # 距离加权
            metric='euclidean'       # 欧氏距离
        )
        model.fit(X_scaled, y)
        
        # 3. 评估（原始尺度）
        y_pred_transformed = model.predict(X_scaled)
        y_pred_original = np.expm1(y_pred_transformed)
        y_true_original = np.expm1(y)
        mse = mean_squared_error(y_true_original, y_pred_original)
        
        # 4. 选择最佳K值
        if mse < best_mse:
            best_model = model
            best_scaler = scaler
    
    # 5. 保存模型
    joblib.dump(best_model, model_path)
    joblib.dump(best_scaler, scaler_path)
```

### 5.2 模型评估指标

- **MSE (Mean Squared Error)** - 均方误差
- **MAE (Mean Absolute Error)** - 平均绝对误差

### 5.3 模型保存

**文件结构：**
```
models/xianwangxianlu/daily/F_PKLCOUNT/{version}/
├── knn_line_{line_no}_daily_v{version}.pkl      # KNN模型
├── knn_scaler_line_{line_no}_daily_v{version}.pkl  # 标准化器
└── model_info_line_{line_no}_daily_v{version}.json  # 模型信息
```

**模型信息包含：**
- 算法类型
- MSE/MAE指标
- 训练日期
- 使用的因子列表
- 算法权重配置

## 六、预测流程

### 6.1 预测步骤

```python
def predict(line_data, line_no, predict_start_date, days, factor_df):
    # 步骤1：KNN预测
    knn_predictions = _predict_knn(...)
    
    # 步骤2：去年同期+偏移预测
    offset_predictions = _calculate_last_year_offset_prediction(...)
    
    # 步骤3：加权融合
    weights = get_line_algorithm_weights(line_no)
    for i in range(days):
        final = weights['knn'] * knn_predictions[i] + \
                weights['last_year_offset'] * offset_predictions[i]
        final_predictions.append(max(final, 0.0))
    
    return final_predictions
```

### 6.2 因子数据获取

**预测时的因子来源：**
1. **优先使用**：`fetch_holiday_features()` 获取的未来因子数据
2. **备用方案**：使用历史数据最后一条记录的因子值
3. **默认值**：因子不存在时填充0

### 6.3 预测结果存储

**数据库表：** `LineDailyFlowPrediction`

**存储字段：**
- `F_DATE` - 预测日期
- `F_LINENO` - 线路编号
- `F_LINENAME` - 线路名称
- `F_PKLCOUNT` - 预测客流值
- `F_HOLIDAYTYPE` - 节假日类型
- `F_WEEK`, `F_DAYOFWEEK` 等因子字段
- `PREDICT_DATE` - 预测生成日期
- `CREATOR` - 创建者标识

## 七、算法特点与优势

### 7.1 KNN算法优势

1. **非参数方法**：不需要假设数据分布
2. **局部模式捕捉**：能够捕捉局部相似性模式
3. **多因子融合**：同时考虑多个特征因子
4. **距离加权**：近邻权重更大，更合理

### 7.2 去年同期+偏移算法优势

1. **季节性捕捉**：充分利用年周期性
2. **趋势调整**：通过偏移量反映趋势变化
3. **稳定性**：基础数据来自历史实际值，更稳定
4. **节假日特化**：针对节假日特殊调整

### 7.3 混合策略优势

1. **互补性**：KNN捕捉复杂模式，偏移算法捕捉周期趋势
2. **鲁棒性**：单一算法失效时，另一算法仍可提供预测
3. **可调性**：通过权重调整适应不同线路特性

## 八、关键参数配置

### 8.1 KNN参数

```python
train_params = {
    "n_neighbors_list": [3, 5, 7, 9],  # K值候选列表
}
```

### 8.2 算法权重

```python
algorithm_weights = {
    "knn": 0.8,
    "last_year_offset": 0.2
}

# 线路级别配置（可选）
line_algorithm_weights = {
    "1": {"knn": 0.7, "last_year_offset": 0.3},
    "2": {"knn": 0.5, "last_year_offset": 0.5},
    # ...
}
```

### 8.3 偏移算法参数

- **偏移区间长度**：默认等于预测天数（days）
- **节假日调整系数**：20%（上浮）
- **最小数据要求**：偏移区间至少50%数据有效

## 九、异常处理与边界情况

### 9.1 数据异常

- **数据不足**：样本数 < 最小K值 → 返回错误
- **特征缺失**：因子列不存在 → 填充0
- **无效值**：NaN或Inf → 报错并终止

### 9.2 预测异常

- **模型文件缺失** → 返回全0预测
- **去年同期数据缺失** → 使用偏移区间平均值
- **所有数据缺失** → 返回0

### 9.3 融合异常

- **KNN预测失败** → 使用全0作为KNN预测值
- **预测结果负值** → 强制为0（max(0.0, prediction)）

## 十、性能优化建议

### 10.1 模型优化

1. **特征选择**：尝试不同的因子组合
2. **K值调优**：扩展K值候选列表
3. **距离度量**：尝试其他距离度量（如曼哈顿距离）

### 10.2 算法权重优化

系统提供了自动优化功能：

```python
# 自动优化权重
predictor.auto_optimize_weights(
    line_data, line_no, 
    test_start_date, test_days=7
)

# 性能评估
predictor.get_algorithm_performance(
    line_data, line_no,
    test_start_date, test_days=7
)
```

### 10.3 数据质量提升

1. **数据完整性**：确保历史数据连续完整
2. **异常值处理**：识别并处理异常数据点
3. **特征工程**：考虑添加新的特征因子

## 十一、使用示例

### 11.1 基本预测

```python
from predict_daily import predict_and_plot_timeseries_flow_daily

result = predict_and_plot_timeseries_flow_daily(
    file_path="",  # 已废弃
    predict_start_date="20250101",
    algorithm="knn",
    days=15,
    flow_type="xianwangxianlu",
    metric_type="F_PKLCOUNT"
)
```

### 11.2 详细预测结果

```python
from enknn_model import KNNFlowPredictor

predictor = KNNFlowPredictor(model_dir, version, config)

# 获取详细预测结果
details = predictor.get_prediction_details(
    line_data, line_no,
    predict_start_date="20250101",
    days=15,
    factor_df=holiday_features
)

# details包含：
# - knn_predictions: KNN单独预测结果
# - offset_predictions: 偏移算法单独预测结果
# - final_predictions: 融合后的最终预测
# - algorithm_weights: 使用的权重配置
```

## 十二、诊断与调试

### 12.1 预测为0的诊断

```python
diagnosis = predictor.diagnose_zero_predictions(
    line_data, line_no, factor_df
)

# diagnosis包含：
# - data_issues: 数据问题列表
# - model_issues: 模型问题列表
# - algorithm_issues: 算法问题列表
# - recommendations: 改进建议
```

### 12.2 性能评估

```python
performance = predictor.get_algorithm_performance(
    line_data, line_no,
    test_start_date="20241201",
    test_days=7
)

# performance包含：
# - knn_performance: KNN算法性能指标
# - offset_performance: 偏移算法性能指标
# - final_performance: 融合算法性能指标
# - best_algorithm: 最佳算法标识
```

## 十三、总结

日客流预测算法采用**KNN回归 + 去年同期偏移**的混合策略，具有以下特点：

1. **双重保障**：两种算法互补，提高预测稳定性
2. **灵活配置**：支持全局和线路级别的权重调整
3. **特征丰富**：使用7个特征因子捕捉多维模式
4. **实用性强**：充分考虑节假日、天气等实际因素
5. **可扩展性**：易于添加新算法和特征

该算法在实际应用中表现稳定，能够有效捕捉客流的时间周期性和趋势变化。

